(self.webpackChunkfmComments=self.webpackChunkfmComments||[]).push([[293],{9773:(w,l,a)=>{a.d(l,{R:()=>b});var n=a(9360),m=a(8251),v=a(4829),d=a(2420);function b(y){return(0,n.e)((f,u)=>{(0,v.Xf)(y).subscribe((0,m.x)(u,()=>u.complete(),d.Z)),!u.closed&&f.subscribe(u)})}},5293:(w,l,a)=>{a.r(l),a.d(l,{takeUntilDestroyed:()=>f,toObservable:()=>u,toSignal:()=>g});var n=a(5559),m=a(5592),v=a(8645);const d={now:()=>(d.delegate||Date).now(),delegate:void 0};class b extends v.x{constructor(e=1/0,i=1/0,t=d){super(),this._bufferSize=e,this._windowTime=i,this._timestampProvider=t,this._buffer=[],this._infiniteTimeWindow=!0,this._infiniteTimeWindow=i===1/0,this._bufferSize=Math.max(1,e),this._windowTime=Math.max(1,i)}next(e){const{isStopped:i,_buffer:t,_infiniteTimeWindow:s,_timestampProvider:o,_windowTime:r}=this;i||(t.push(e),!s&&t.push(o.now()+r)),this._trimBuffer(),super.next(e)}_subscribe(e){this._throwIfClosed(),this._trimBuffer();const i=this._innerSubscribe(e),{_infiniteTimeWindow:t,_buffer:s}=this,o=s.slice();for(let r=0;r<o.length&&!e.closed;r+=t?1:2)e.next(o[r]);return this._checkFinalizedStatuses(e),i}_trimBuffer(){const{_bufferSize:e,_timestampProvider:i,_buffer:t,_infiniteTimeWindow:s}=this,o=(s?1:2)*e;if(e<1/0&&o<t.length&&t.splice(0,t.length-o),!s){const r=i.now();let _=0;for(let h=1;h<t.length&&t[h]<=r;h+=2)_=h;_&&t.splice(0,_+1)}}}var y=a(9773);function f(c){c||((0,n.assertInInjectionContext)(f),c=(0,n.inject)(n.DestroyRef));const e=new m.y(i=>c.onDestroy(i.next.bind(i)));return i=>i.pipe((0,y.R)(e))}function u(c,e){!e?.injector&&(0,n.assertInInjectionContext)(u);const i=e?.injector??(0,n.inject)(n.Injector),t=new b(1),s=(0,n.effect)(()=>{let o;try{o=c()}catch(r){return void(0,n.untracked)(()=>t.error(r))}(0,n.untracked)(()=>t.next(o))},{injector:i,manualCleanup:!0});return i.get(n.DestroyRef).onDestroy(()=>{s.destroy(),t.complete()}),t.asObservable()}function g(c,e){const i=!e?.manualCleanup;i&&!e?.injector&&(0,n.assertInInjectionContext)(g);const t=i?e?.injector?.get(n.DestroyRef)??(0,n.inject)(n.DestroyRef):null;let s;s=(0,n.signal)(e?.requireSync?{kind:0}:{kind:1,value:e?.initialValue});const o=c.subscribe({next:r=>s.set({kind:1,value:r}),error:r=>{if(e?.rejectErrors)throw r;s.set({kind:2,error:r})}});return t?.onDestroy(o.unsubscribe.bind(o)),(0,n.computed)(()=>{const r=s();switch(r.kind){case 1:return r.value;case 2:throw r.error;case 0:throw new n.\u0275RuntimeError(601,"`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.")}})}}}]);